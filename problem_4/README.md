# 문제 4

아래의 요구조건에 맞는 설계를 진행하고, 이유를 설명해주세요

작은 스타트업에서 BO 서비스에서 통계 서비스를 개발하여 합니다

1. 각 콘텐츠의 유저의 클릭수, 좋아요수를 보여주는 그래프를 그려야 합니다
2. 클릭과 좋아요 수는 BO의 대시보드에서 확인이 가능하며, 새로고침 버튼을 눌러서 갱신 가능합니다
3. 그래프는 일일 단위로 합계로 표시됩니다

---

# Solution

### 1. 반정규화

- 콘텐츠의 테이블을 반정규화 하여 clickCount, likeCount 컬럼을 추가합니다.
- 좋아요의 경우 특정 유저가 좋아요 했는지 (isLike) 같은 정보를 알아야한다면 Like 테이블을 생성합니다.

### 2. API 로직

- click api, like api를 만들어 (필요하다면 트랜잭션) 반정규화된 Count 컬럼을 +1 씩 합니다.
- 클릭 또는 좋아요 api가 실행된다면 DynamoDB에 contentType, contentId, clickCount, likeCount 를 저장합니다.
- 만료일자(deleteAt) 컬럼을 추가해 데이터가 수정되는 시점으로부터 24시간 후에 자동으로 데이터가 삭제되도록 설정합니다.

### 3. Statistics 테이블 생성

- contentType, contentId, clickCount, likeCount, date 컬럼을 가집니다.
- 그 날 생성된 clickCount를 저장하는게 아니라 그 시점 컨텐츠가 가지고 있는 누적 clickCount를 저장합니다.
- 기간이 오래되고 데이터가 많아진다면 date 컬럼을 기준으로 파티셔닝을 할 수 있습니다.
- MongoDB같은 NoSQL 데이터베이스를 사용하면 더 좋습니다.

### 4. Cronjob

- 매일 23시 59분에 실행되는 Lambda 함수를 통해 DynamoDB에 저장되어 있는 모든 데이터를 꺼내 Statistics 테이블에 저장합니다.
- 데이터가 변동되지 않은 날엔 저장되지 않기에 저장공간을 절약할 수 있습니다.

### 5. DynamoDB 선택 이유

- 만료일자 컬럼을 설정할 수 있어 처리된 데이터를 삭제하는 쿼리를 사용하지 않아도 자동으로 삭제가 가능해 WCU를 절약할 수 있습니다.
- contentType, contentId를 pk로 설정하면 기존 데이터를 덮어쓰는 식으로 업데이트를 할 수 있습니다.
- DynamoDB를 임시 데이터베이스로 사용한 프로세스 분리 방식으로 인해 매 요청마다 메인 데이터베이스에서 실행되야 했던 비효율적인 update 로직을 개선할 수 있습니다.

### 6. 대시보드 조회

- 실제 조회되는 사례(범위 기간 조회인지, 특정 날짜를 인자로 받는지)에 따라 다르겠지만 대부분의 사례에 대응이 가능합니다.

### 💡 추가질문 1. - 실제로 구현해본 경험이 있다면, 해당 구현 경험을 서술해주세요

- 사이드 프로젝트에서 검색용 데이터베이스에 저장된 정렬 필드(likeCount)를 최신화 해야해서 비슷한 로직으로 구현한 경험이 있습니다.

### 💡 추가질문 2. - 유저가 클릭을 조작하기위해 빠르게 연타를 한다면, 어떻게 방지할수 있을까요?

- 프론트단에서 Debounce을 추가하는 것이 가장 효과적입니다.
